// This file is auto-generated by @hey-api/openapi-ts

import { type Options, appControllerGetHello, appControllerHealthCheck, usersControllerFindAll, usersControllerCreate, usersControllerRemove, usersControllerFindOne, usersControllerUpdate, usersControllerClearCart, usersControllerAddToCart, productsControllerFindAll, productsControllerCreate, productsControllerGetProductsByName, productsControllerGetRandomProducts, productsControllerRemove, productsControllerFindOne, productsControllerUpdate, recipesControllerFindAll, recipesControllerCreate, recipesControllerGetRecipesByName, recipesControllerGetRandomRecipes, recipesControllerRemove, recipesControllerFindOne, recipesControllerUpdate, packagesControllerFindAll, packagesControllerCreate, packagesControllerGetRandomPackages, packagesControllerRemove, packagesControllerFindOne, packagesControllerUpdate, ordersControllerFindAll, ordersControllerCreate, ordersControllerGenerateSale, ordersControllerHandlePaymentWebhook, ordersControllerNotify, ordersControllerFindByCustomerEmail, ordersControllerRemove, ordersControllerFindOne, ordersControllerUpdate, uploadControllerUploadImagesPublic, uploadControllerUploadImages } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { AppControllerGetHelloData, AppControllerHealthCheckData, UsersControllerFindAllData, UsersControllerCreateData, UsersControllerCreateResponse, UsersControllerRemoveData, UsersControllerFindOneData, UsersControllerUpdateData, UsersControllerUpdateResponse, UsersControllerClearCartData, UsersControllerClearCartResponse, UsersControllerAddToCartData, UsersControllerAddToCartResponse, ProductsControllerFindAllData, ProductsControllerFindAllResponse, ProductsControllerCreateData, ProductsControllerCreateResponse, ProductsControllerGetProductsByNameData, ProductsControllerGetProductsByNameResponse, ProductsControllerGetRandomProductsData, ProductsControllerGetRandomProductsResponse, ProductsControllerRemoveData, ProductsControllerFindOneData, ProductsControllerUpdateData, ProductsControllerUpdateResponse, RecipesControllerFindAllData, RecipesControllerFindAllResponse, RecipesControllerCreateData, RecipesControllerCreateResponse, RecipesControllerGetRecipesByNameData, RecipesControllerGetRandomRecipesData, RecipesControllerGetRandomRecipesResponse, RecipesControllerRemoveData, RecipesControllerFindOneData, RecipesControllerUpdateData, RecipesControllerUpdateResponse, PackagesControllerFindAllData, PackagesControllerFindAllResponse, PackagesControllerCreateData, PackagesControllerCreateResponse, PackagesControllerGetRandomPackagesData, PackagesControllerGetRandomPackagesResponse, PackagesControllerRemoveData, PackagesControllerFindOneData, PackagesControllerUpdateData, PackagesControllerUpdateResponse, OrdersControllerFindAllData, OrdersControllerFindAllResponse, OrdersControllerCreateData, OrdersControllerCreateResponse, OrdersControllerGenerateSaleData, OrdersControllerGenerateSaleResponse, OrdersControllerHandlePaymentWebhookData, OrdersControllerHandlePaymentWebhookResponse, OrdersControllerNotifyData, OrdersControllerFindByCustomerEmailData, OrdersControllerRemoveData, OrdersControllerFindOneData, OrdersControllerUpdateData, OrdersControllerUpdateResponse, UploadControllerUploadImagesPublicData, UploadControllerUploadImagesPublicResponse, UploadControllerUploadImagesData, UploadControllerUploadImagesResponse } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const appControllerGetHelloQueryKey = (options?: Options<AppControllerGetHelloData>) => createQueryKey('appControllerGetHello', options);

export const appControllerGetHelloOptions = (options?: Options<AppControllerGetHelloData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await appControllerGetHello({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: appControllerGetHelloQueryKey(options)
    });
};

export const appControllerHealthCheckQueryKey = (options?: Options<AppControllerHealthCheckData>) => createQueryKey('appControllerHealthCheck', options);

export const appControllerHealthCheckOptions = (options?: Options<AppControllerHealthCheckData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await appControllerHealthCheck({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: appControllerHealthCheckQueryKey(options)
    });
};

export const usersControllerFindAllQueryKey = (options?: Options<UsersControllerFindAllData>) => createQueryKey('usersControllerFindAll', options);

export const usersControllerFindAllOptions = (options?: Options<UsersControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerFindAllQueryKey(options)
    });
};

export const usersControllerCreateQueryKey = (options: Options<UsersControllerCreateData>) => createQueryKey('usersControllerCreate', options);

export const usersControllerCreateOptions = (options: Options<UsersControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerCreateQueryKey(options)
    });
};

export const usersControllerCreateMutation = (options?: Partial<Options<UsersControllerCreateData>>): UseMutationOptions<UsersControllerCreateResponse, DefaultError, Options<UsersControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerCreateResponse, DefaultError, Options<UsersControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerRemoveMutation = (options?: Partial<Options<UsersControllerRemoveData>>): UseMutationOptions<unknown, DefaultError, Options<UsersControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UsersControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerFindOneQueryKey = (options: Options<UsersControllerFindOneData>) => createQueryKey('usersControllerFindOne', options);

export const usersControllerFindOneOptions = (options: Options<UsersControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerFindOneQueryKey(options)
    });
};

export const usersControllerUpdateMutation = (options?: Partial<Options<UsersControllerUpdateData>>): UseMutationOptions<UsersControllerUpdateResponse, DefaultError, Options<UsersControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerUpdateResponse, DefaultError, Options<UsersControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerClearCartMutation = (options?: Partial<Options<UsersControllerClearCartData>>): UseMutationOptions<UsersControllerClearCartResponse, DefaultError, Options<UsersControllerClearCartData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerClearCartResponse, DefaultError, Options<UsersControllerClearCartData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerClearCart({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerAddToCartQueryKey = (options: Options<UsersControllerAddToCartData>) => createQueryKey('usersControllerAddToCart', options);

export const usersControllerAddToCartOptions = (options: Options<UsersControllerAddToCartData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerAddToCart({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerAddToCartQueryKey(options)
    });
};

export const usersControllerAddToCartMutation = (options?: Partial<Options<UsersControllerAddToCartData>>): UseMutationOptions<UsersControllerAddToCartResponse, DefaultError, Options<UsersControllerAddToCartData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerAddToCartResponse, DefaultError, Options<UsersControllerAddToCartData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerAddToCart({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const productsControllerFindAllQueryKey = (options: Options<ProductsControllerFindAllData>) => createQueryKey('productsControllerFindAll', options);

export const productsControllerFindAllOptions = (options: Options<ProductsControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await productsControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: productsControllerFindAllQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const productsControllerFindAllInfiniteQueryKey = (options: Options<ProductsControllerFindAllData>): QueryKey<Options<ProductsControllerFindAllData>> => createQueryKey('productsControllerFindAll', options, true);

export const productsControllerFindAllInfiniteOptions = (options: Options<ProductsControllerFindAllData>) => {
    return infiniteQueryOptions<ProductsControllerFindAllResponse, DefaultError, InfiniteData<ProductsControllerFindAllResponse>, QueryKey<Options<ProductsControllerFindAllData>>, number | Pick<QueryKey<Options<ProductsControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ProductsControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await productsControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: productsControllerFindAllInfiniteQueryKey(options)
    });
};

export const productsControllerCreateQueryKey = (options: Options<ProductsControllerCreateData>) => createQueryKey('productsControllerCreate', options);

export const productsControllerCreateOptions = (options: Options<ProductsControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await productsControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: productsControllerCreateQueryKey(options)
    });
};

export const productsControllerCreateMutation = (options?: Partial<Options<ProductsControllerCreateData>>): UseMutationOptions<ProductsControllerCreateResponse, DefaultError, Options<ProductsControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<ProductsControllerCreateResponse, DefaultError, Options<ProductsControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await productsControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const productsControllerGetProductsByNameQueryKey = (options?: Options<ProductsControllerGetProductsByNameData>) => createQueryKey('productsControllerGetProductsByName', options);

export const productsControllerGetProductsByNameOptions = (options?: Options<ProductsControllerGetProductsByNameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await productsControllerGetProductsByName({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: productsControllerGetProductsByNameQueryKey(options)
    });
};

export const productsControllerGetProductsByNameMutation = (options?: Partial<Options<ProductsControllerGetProductsByNameData>>): UseMutationOptions<ProductsControllerGetProductsByNameResponse, DefaultError, Options<ProductsControllerGetProductsByNameData>> => {
    const mutationOptions: UseMutationOptions<ProductsControllerGetProductsByNameResponse, DefaultError, Options<ProductsControllerGetProductsByNameData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await productsControllerGetProductsByName({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const productsControllerGetRandomProductsQueryKey = (options: Options<ProductsControllerGetRandomProductsData>) => createQueryKey('productsControllerGetRandomProducts', options);

export const productsControllerGetRandomProductsOptions = (options: Options<ProductsControllerGetRandomProductsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await productsControllerGetRandomProducts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: productsControllerGetRandomProductsQueryKey(options)
    });
};

export const productsControllerGetRandomProductsInfiniteQueryKey = (options: Options<ProductsControllerGetRandomProductsData>): QueryKey<Options<ProductsControllerGetRandomProductsData>> => createQueryKey('productsControllerGetRandomProducts', options, true);

export const productsControllerGetRandomProductsInfiniteOptions = (options: Options<ProductsControllerGetRandomProductsData>) => {
    return infiniteQueryOptions<ProductsControllerGetRandomProductsResponse, DefaultError, InfiniteData<ProductsControllerGetRandomProductsResponse>, QueryKey<Options<ProductsControllerGetRandomProductsData>>, number | Pick<QueryKey<Options<ProductsControllerGetRandomProductsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ProductsControllerGetRandomProductsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await productsControllerGetRandomProducts({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: productsControllerGetRandomProductsInfiniteQueryKey(options)
    });
};

export const productsControllerRemoveMutation = (options?: Partial<Options<ProductsControllerRemoveData>>): UseMutationOptions<unknown, DefaultError, Options<ProductsControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ProductsControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await productsControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const productsControllerFindOneQueryKey = (options: Options<ProductsControllerFindOneData>) => createQueryKey('productsControllerFindOne', options);

export const productsControllerFindOneOptions = (options: Options<ProductsControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await productsControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: productsControllerFindOneQueryKey(options)
    });
};

export const productsControllerUpdateMutation = (options?: Partial<Options<ProductsControllerUpdateData>>): UseMutationOptions<ProductsControllerUpdateResponse, DefaultError, Options<ProductsControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<ProductsControllerUpdateResponse, DefaultError, Options<ProductsControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await productsControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const recipesControllerFindAllQueryKey = (options: Options<RecipesControllerFindAllData>) => createQueryKey('recipesControllerFindAll', options);

export const recipesControllerFindAllOptions = (options: Options<RecipesControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await recipesControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: recipesControllerFindAllQueryKey(options)
    });
};

export const recipesControllerFindAllInfiniteQueryKey = (options: Options<RecipesControllerFindAllData>): QueryKey<Options<RecipesControllerFindAllData>> => createQueryKey('recipesControllerFindAll', options, true);

export const recipesControllerFindAllInfiniteOptions = (options: Options<RecipesControllerFindAllData>) => {
    return infiniteQueryOptions<RecipesControllerFindAllResponse, DefaultError, InfiniteData<RecipesControllerFindAllResponse>, QueryKey<Options<RecipesControllerFindAllData>>, number | Pick<QueryKey<Options<RecipesControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<RecipesControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await recipesControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: recipesControllerFindAllInfiniteQueryKey(options)
    });
};

export const recipesControllerCreateQueryKey = (options: Options<RecipesControllerCreateData>) => createQueryKey('recipesControllerCreate', options);

export const recipesControllerCreateOptions = (options: Options<RecipesControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await recipesControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: recipesControllerCreateQueryKey(options)
    });
};

export const recipesControllerCreateMutation = (options?: Partial<Options<RecipesControllerCreateData>>): UseMutationOptions<RecipesControllerCreateResponse, DefaultError, Options<RecipesControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<RecipesControllerCreateResponse, DefaultError, Options<RecipesControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await recipesControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const recipesControllerGetRecipesByNameQueryKey = (options: Options<RecipesControllerGetRecipesByNameData>) => createQueryKey('recipesControllerGetRecipesByName', options);

export const recipesControllerGetRecipesByNameOptions = (options: Options<RecipesControllerGetRecipesByNameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await recipesControllerGetRecipesByName({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: recipesControllerGetRecipesByNameQueryKey(options)
    });
};

export const recipesControllerGetRandomRecipesQueryKey = (options: Options<RecipesControllerGetRandomRecipesData>) => createQueryKey('recipesControllerGetRandomRecipes', options);

export const recipesControllerGetRandomRecipesOptions = (options: Options<RecipesControllerGetRandomRecipesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await recipesControllerGetRandomRecipes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: recipesControllerGetRandomRecipesQueryKey(options)
    });
};

export const recipesControllerGetRandomRecipesInfiniteQueryKey = (options: Options<RecipesControllerGetRandomRecipesData>): QueryKey<Options<RecipesControllerGetRandomRecipesData>> => createQueryKey('recipesControllerGetRandomRecipes', options, true);

export const recipesControllerGetRandomRecipesInfiniteOptions = (options: Options<RecipesControllerGetRandomRecipesData>) => {
    return infiniteQueryOptions<RecipesControllerGetRandomRecipesResponse, DefaultError, InfiniteData<RecipesControllerGetRandomRecipesResponse>, QueryKey<Options<RecipesControllerGetRandomRecipesData>>, number | Pick<QueryKey<Options<RecipesControllerGetRandomRecipesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<RecipesControllerGetRandomRecipesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await recipesControllerGetRandomRecipes({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: recipesControllerGetRandomRecipesInfiniteQueryKey(options)
    });
};

export const recipesControllerRemoveMutation = (options?: Partial<Options<RecipesControllerRemoveData>>): UseMutationOptions<unknown, DefaultError, Options<RecipesControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RecipesControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await recipesControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const recipesControllerFindOneQueryKey = (options: Options<RecipesControllerFindOneData>) => createQueryKey('recipesControllerFindOne', options);

export const recipesControllerFindOneOptions = (options: Options<RecipesControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await recipesControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: recipesControllerFindOneQueryKey(options)
    });
};

export const recipesControllerUpdateMutation = (options?: Partial<Options<RecipesControllerUpdateData>>): UseMutationOptions<RecipesControllerUpdateResponse, DefaultError, Options<RecipesControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<RecipesControllerUpdateResponse, DefaultError, Options<RecipesControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await recipesControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const packagesControllerFindAllQueryKey = (options: Options<PackagesControllerFindAllData>) => createQueryKey('packagesControllerFindAll', options);

export const packagesControllerFindAllOptions = (options: Options<PackagesControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await packagesControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: packagesControllerFindAllQueryKey(options)
    });
};

export const packagesControllerFindAllInfiniteQueryKey = (options: Options<PackagesControllerFindAllData>): QueryKey<Options<PackagesControllerFindAllData>> => createQueryKey('packagesControllerFindAll', options, true);

export const packagesControllerFindAllInfiniteOptions = (options: Options<PackagesControllerFindAllData>) => {
    return infiniteQueryOptions<PackagesControllerFindAllResponse, DefaultError, InfiniteData<PackagesControllerFindAllResponse>, QueryKey<Options<PackagesControllerFindAllData>>, number | Pick<QueryKey<Options<PackagesControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<PackagesControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await packagesControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: packagesControllerFindAllInfiniteQueryKey(options)
    });
};

export const packagesControllerCreateQueryKey = (options: Options<PackagesControllerCreateData>) => createQueryKey('packagesControllerCreate', options);

export const packagesControllerCreateOptions = (options: Options<PackagesControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await packagesControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: packagesControllerCreateQueryKey(options)
    });
};

export const packagesControllerCreateMutation = (options?: Partial<Options<PackagesControllerCreateData>>): UseMutationOptions<PackagesControllerCreateResponse, DefaultError, Options<PackagesControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<PackagesControllerCreateResponse, DefaultError, Options<PackagesControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await packagesControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const packagesControllerGetRandomPackagesQueryKey = (options: Options<PackagesControllerGetRandomPackagesData>) => createQueryKey('packagesControllerGetRandomPackages', options);

export const packagesControllerGetRandomPackagesOptions = (options: Options<PackagesControllerGetRandomPackagesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await packagesControllerGetRandomPackages({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: packagesControllerGetRandomPackagesQueryKey(options)
    });
};

export const packagesControllerGetRandomPackagesInfiniteQueryKey = (options: Options<PackagesControllerGetRandomPackagesData>): QueryKey<Options<PackagesControllerGetRandomPackagesData>> => createQueryKey('packagesControllerGetRandomPackages', options, true);

export const packagesControllerGetRandomPackagesInfiniteOptions = (options: Options<PackagesControllerGetRandomPackagesData>) => {
    return infiniteQueryOptions<PackagesControllerGetRandomPackagesResponse, DefaultError, InfiniteData<PackagesControllerGetRandomPackagesResponse>, QueryKey<Options<PackagesControllerGetRandomPackagesData>>, number | Pick<QueryKey<Options<PackagesControllerGetRandomPackagesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<PackagesControllerGetRandomPackagesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await packagesControllerGetRandomPackages({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: packagesControllerGetRandomPackagesInfiniteQueryKey(options)
    });
};

export const packagesControllerRemoveMutation = (options?: Partial<Options<PackagesControllerRemoveData>>): UseMutationOptions<unknown, DefaultError, Options<PackagesControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<PackagesControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await packagesControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const packagesControllerFindOneQueryKey = (options: Options<PackagesControllerFindOneData>) => createQueryKey('packagesControllerFindOne', options);

export const packagesControllerFindOneOptions = (options: Options<PackagesControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await packagesControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: packagesControllerFindOneQueryKey(options)
    });
};

export const packagesControllerUpdateMutation = (options?: Partial<Options<PackagesControllerUpdateData>>): UseMutationOptions<PackagesControllerUpdateResponse, DefaultError, Options<PackagesControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<PackagesControllerUpdateResponse, DefaultError, Options<PackagesControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await packagesControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const ordersControllerFindAllQueryKey = (options?: Options<OrdersControllerFindAllData>) => createQueryKey('ordersControllerFindAll', options);

/**
 * Get all orders with pagination
 */
export const ordersControllerFindAllOptions = (options?: Options<OrdersControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ordersControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersControllerFindAllQueryKey(options)
    });
};

export const ordersControllerFindAllInfiniteQueryKey = (options?: Options<OrdersControllerFindAllData>): QueryKey<Options<OrdersControllerFindAllData>> => createQueryKey('ordersControllerFindAll', options, true);

/**
 * Get all orders with pagination
 */
export const ordersControllerFindAllInfiniteOptions = (options?: Options<OrdersControllerFindAllData>) => {
    return infiniteQueryOptions<OrdersControllerFindAllResponse, DefaultError, InfiniteData<OrdersControllerFindAllResponse>, QueryKey<Options<OrdersControllerFindAllData>>, number | Pick<QueryKey<Options<OrdersControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<OrdersControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await ordersControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersControllerFindAllInfiniteQueryKey(options)
    });
};

export const ordersControllerCreateQueryKey = (options: Options<OrdersControllerCreateData>) => createQueryKey('ordersControllerCreate', options);

/**
 * Create a new order
 */
export const ordersControllerCreateOptions = (options: Options<OrdersControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ordersControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersControllerCreateQueryKey(options)
    });
};

/**
 * Create a new order
 */
export const ordersControllerCreateMutation = (options?: Partial<Options<OrdersControllerCreateData>>): UseMutationOptions<OrdersControllerCreateResponse, DefaultError, Options<OrdersControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<OrdersControllerCreateResponse, DefaultError, Options<OrdersControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await ordersControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const ordersControllerGenerateSaleQueryKey = (options: Options<OrdersControllerGenerateSaleData>) => createQueryKey('ordersControllerGenerateSale', options);

/**
 * Generate sale order with PayPlus payment link
 * Creates order from minimal cart data, verifies pricing from database, and generates PayPlus payment link
 */
export const ordersControllerGenerateSaleOptions = (options: Options<OrdersControllerGenerateSaleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ordersControllerGenerateSale({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersControllerGenerateSaleQueryKey(options)
    });
};

/**
 * Generate sale order with PayPlus payment link
 * Creates order from minimal cart data, verifies pricing from database, and generates PayPlus payment link
 */
export const ordersControllerGenerateSaleMutation = (options?: Partial<Options<OrdersControllerGenerateSaleData>>): UseMutationOptions<OrdersControllerGenerateSaleResponse, DefaultError, Options<OrdersControllerGenerateSaleData>> => {
    const mutationOptions: UseMutationOptions<OrdersControllerGenerateSaleResponse, DefaultError, Options<OrdersControllerGenerateSaleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await ordersControllerGenerateSale({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const ordersControllerHandlePaymentWebhookQueryKey = (options: Options<OrdersControllerHandlePaymentWebhookData>) => createQueryKey('ordersControllerHandlePaymentWebhook', options);

/**
 * Handle PayPlus payment webhook
 * Receives and processes payment status updates from PayPlus
 */
export const ordersControllerHandlePaymentWebhookOptions = (options: Options<OrdersControllerHandlePaymentWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ordersControllerHandlePaymentWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersControllerHandlePaymentWebhookQueryKey(options)
    });
};

/**
 * Handle PayPlus payment webhook
 * Receives and processes payment status updates from PayPlus
 */
export const ordersControllerHandlePaymentWebhookMutation = (options?: Partial<Options<OrdersControllerHandlePaymentWebhookData>>): UseMutationOptions<OrdersControllerHandlePaymentWebhookResponse, DefaultError, Options<OrdersControllerHandlePaymentWebhookData>> => {
    const mutationOptions: UseMutationOptions<OrdersControllerHandlePaymentWebhookResponse, DefaultError, Options<OrdersControllerHandlePaymentWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await ordersControllerHandlePaymentWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const ordersControllerNotifyQueryKey = (options?: Options<OrdersControllerNotifyData>) => createQueryKey('ordersControllerNotify', options);

/**
 * Legacy payment notification endpoint
 * Legacy endpoint for payment notifications (use webhook/payment-notification instead)
 */
export const ordersControllerNotifyOptions = (options?: Options<OrdersControllerNotifyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ordersControllerNotify({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersControllerNotifyQueryKey(options)
    });
};

/**
 * Legacy payment notification endpoint
 * Legacy endpoint for payment notifications (use webhook/payment-notification instead)
 */
export const ordersControllerNotifyMutation = (options?: Partial<Options<OrdersControllerNotifyData>>): UseMutationOptions<unknown, DefaultError, Options<OrdersControllerNotifyData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<OrdersControllerNotifyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await ordersControllerNotify({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const ordersControllerFindByCustomerEmailQueryKey = (options: Options<OrdersControllerFindByCustomerEmailData>) => createQueryKey('ordersControllerFindByCustomerEmail', options);

/**
 * Get orders by customer email
 */
export const ordersControllerFindByCustomerEmailOptions = (options: Options<OrdersControllerFindByCustomerEmailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ordersControllerFindByCustomerEmail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersControllerFindByCustomerEmailQueryKey(options)
    });
};

/**
 * Delete order by ID
 */
export const ordersControllerRemoveMutation = (options?: Partial<Options<OrdersControllerRemoveData>>): UseMutationOptions<unknown, DefaultError, Options<OrdersControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<OrdersControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await ordersControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const ordersControllerFindOneQueryKey = (options: Options<OrdersControllerFindOneData>) => createQueryKey('ordersControllerFindOne', options);

/**
 * Get order by ID
 */
export const ordersControllerFindOneOptions = (options: Options<OrdersControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ordersControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersControllerFindOneQueryKey(options)
    });
};

/**
 * Update order by ID
 */
export const ordersControllerUpdateMutation = (options?: Partial<Options<OrdersControllerUpdateData>>): UseMutationOptions<OrdersControllerUpdateResponse, DefaultError, Options<OrdersControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<OrdersControllerUpdateResponse, DefaultError, Options<OrdersControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await ordersControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const uploadControllerUploadImagesPublicQueryKey = (options: Options<UploadControllerUploadImagesPublicData>) => createQueryKey('uploadControllerUploadImagesPublic', options);

/**
 * Upload images (Public)
 * Public endpoint for uploading images. No authentication required but has stricter rate limits and file restrictions.
 */
export const uploadControllerUploadImagesPublicOptions = (options: Options<UploadControllerUploadImagesPublicData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await uploadControllerUploadImagesPublic({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: uploadControllerUploadImagesPublicQueryKey(options)
    });
};

/**
 * Upload images (Public)
 * Public endpoint for uploading images. No authentication required but has stricter rate limits and file restrictions.
 */
export const uploadControllerUploadImagesPublicMutation = (options?: Partial<Options<UploadControllerUploadImagesPublicData>>): UseMutationOptions<UploadControllerUploadImagesPublicResponse, DefaultError, Options<UploadControllerUploadImagesPublicData>> => {
    const mutationOptions: UseMutationOptions<UploadControllerUploadImagesPublicResponse, DefaultError, Options<UploadControllerUploadImagesPublicData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await uploadControllerUploadImagesPublic({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const uploadControllerUploadImagesQueryKey = (options: Options<UploadControllerUploadImagesData>) => createQueryKey('uploadControllerUploadImages', options);

/**
 * Upload images (Authenticated)
 * Authenticated endpoint for uploading images. Requires valid JWT token and upload permissions. Higher file limits.
 */
export const uploadControllerUploadImagesOptions = (options: Options<UploadControllerUploadImagesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await uploadControllerUploadImages({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: uploadControllerUploadImagesQueryKey(options)
    });
};

/**
 * Upload images (Authenticated)
 * Authenticated endpoint for uploading images. Requires valid JWT token and upload permissions. Higher file limits.
 */
export const uploadControllerUploadImagesMutation = (options?: Partial<Options<UploadControllerUploadImagesData>>): UseMutationOptions<UploadControllerUploadImagesResponse, DefaultError, Options<UploadControllerUploadImagesData>> => {
    const mutationOptions: UseMutationOptions<UploadControllerUploadImagesResponse, DefaultError, Options<UploadControllerUploadImagesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await uploadControllerUploadImages({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};